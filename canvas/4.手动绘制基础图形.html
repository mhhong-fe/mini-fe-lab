<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Canvas äº¤äº’æ¼”ç¤ºï¼šç‚¹/çº¿/çŸ©å½¢/åœ†</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f9f9f9;
            padding: 40px;
        }

        h2 {
            margin-bottom: 16px;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }

        button {
            padding: 6px 14px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        button.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }

        canvas {
            background: white;
            border: 1px solid #ccc;
        }
    </style>
</head>

<body>
    <h2>ğŸ¨ Canvas äº¤äº’æ¼”ç¤ºï¼šç‚¹ / çº¿ / çŸ©å½¢ / åœ†</h2>
    <div class="toolbar">
        <button data-mode="point" class="active">ç‚¹å‡»ç»˜ç‚¹</button>
        <button data-mode="line">æ‹–æ‹½ç»˜çº¿</button>
        <button data-mode="rect">æ‹–æ‹½çŸ©å½¢</button>
        <button data-mode="circle">æ‹–æ‹½åœ†</button>
        <button id="clear">æ¸…ç©º</button>
    </div>
    <canvas id="canvas" width="600" height="400"></canvas>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const buttons = document.querySelectorAll("button[data-mode]");
        const clearBtn = document.getElementById("clear");

        const LOGICAL_WIDTH = 600;
        const LOGICAL_HEIGHT = 400;

        let mode = "point";
        let isDrawing = false;
        let startPoint = null;

        const points = [];
        const lines = [];
        const rectangles = [];
        const circles = [];

        // é«˜åˆ†å±é€‚é…
        function scaleCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = LOGICAL_WIDTH * dpr;
            canvas.height = LOGICAL_HEIGHT * dpr;
            canvas.style.width = LOGICAL_WIDTH + "px";
            canvas.style.height = LOGICAL_HEIGHT + "px";
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // ç»˜åˆ¶ç½‘æ ¼å’Œåæ ‡è½´
        function drawGrid() {
            ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);

            ctx.strokeStyle = "#eee";
            ctx.lineWidth = 1;
            for (let x = 0; x <= LOGICAL_WIDTH; x += 50) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, LOGICAL_HEIGHT); ctx.stroke();
            }
            for (let y = 0; y <= LOGICAL_HEIGHT; y += 50) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(LOGICAL_WIDTH, y); ctx.stroke();
            }

            ctx.strokeStyle = "#333";
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(LOGICAL_WIDTH, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, LOGICAL_HEIGHT); ctx.stroke();

            ctx.fillStyle = "#666";
            ctx.font = "12px sans-serif";
            for (let x = 0; x <= LOGICAL_WIDTH; x += 50) ctx.fillText(x, x + 2, 12);
            for (let y = 50; y <= LOGICAL_HEIGHT; y += 50) ctx.fillText(y, 2, y - 2);
        }

        // é‡ç»˜æ‰€æœ‰å…ƒç´ 
        function redraw() {
            drawGrid();

            ctx.fillStyle = "red";
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.strokeStyle = "blue";
            ctx.lineWidth = 2;
            lines.forEach(([p1, p2]) => {
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            });

            ctx.strokeStyle = "orange";
            rectangles.forEach(r => {
                ctx.strokeRect(r.x, r.y, r.w, r.h);
            });

            ctx.strokeStyle = "green";
            circles.forEach(c => {
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        // è·å–é¼ æ ‡åœ¨ canvas ä¸­çš„ä½ç½®
        function getCanvasPos(e) {
            const rect = canvas.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        // é¼ æ ‡äº¤äº’
        canvas.addEventListener("mousedown", e => {
            const pos = getCanvasPos(e);
            if (mode === "point") {
                points.push(pos); 
                redraw();
            } else {
                isDrawing = true; 
                startPoint = pos;
            }
        });

        canvas.addEventListener("mousemove", e => {
            if (!isDrawing) return;
            const pos = getCanvasPos(e);
            redraw();

            if (mode === "line") {
                ctx.strokeStyle = "rgba(0,0,255,0.5)";
                ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(pos.x, pos.y); ctx.stroke();
            } else if (mode === "rect") {
                ctx.strokeStyle = "orange";
                ctx.lineWidth = 2;
                ctx.strokeRect(startPoint.x, startPoint.y, pos.x - startPoint.x, pos.y - startPoint.y);
            } else if (mode === "circle") {
                const r = Math.hypot(pos.x - startPoint.x, pos.y - startPoint.y);
                ctx.strokeStyle = "green";
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, r, 0, Math.PI * 2); ctx.stroke();
            }
        });

        canvas.addEventListener("mouseup", e => {
            const pos = getCanvasPos(e);
            if (!isDrawing) return;
            if (mode === "line") {
                lines.push([startPoint, pos]);
            } else if (mode === "rect") {
                rectangles.push({ 
                    x: startPoint.x, 
                    y: startPoint.y, 
                    w: pos.x - startPoint.x, 
                    h: pos.y - startPoint.y 
                });
            } else if (mode === "circle") {
                circles.push({ 
                    x: startPoint.x, 
                    y: startPoint.y, 
                    r: Math.hypot(pos.x - startPoint.x, pos.y - startPoint.y) 
                });
            }
            isDrawing = false;
            redraw();
        });

        // æ¨¡å¼åˆ‡æ¢
        buttons.forEach(btn => {
            btn.addEventListener("click", () => {
                mode = btn.dataset.mode;
                buttons.forEach(b => b.classList.toggle("active", b === btn));
            });
        });

        // æ¸…ç©º
        clearBtn.addEventListener("click", () => {
            points.length = 0; lines.length = 0; rectangles.length = 0; circles.length = 0;
            redraw();
        });

        scaleCanvas();
        redraw();
    </script>
</body>

</html>